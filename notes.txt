import pandas as pd
from statsmodels.tsa.arima.model import ARIMA
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error
import numpy as np
import matplotlib.pyplot as plt

# Load your dataset
df = pd.read_csv("your_data.csv")

# Convert 'Close Month' and 'Close Year' to datetime
df['Close Month'] = pd.to_datetime(df['Close Month'].astype(int).astype(str) + '-' + df['Close Year'].astype(int).astype(str), format='%m-%Y')

# Set 'Close Month' as the index
df.set_index('Close Month', inplace=True)

# Recognize current year and month
current_year = df.index[-1].year
current_month = df.index[-1].month

# Filter data for the specified countries and the current year
countries = ['AUS', 'USIS', 'CAN']
df_current_year = df[(df.index.year == current_year) & (df['BU/COE'].isin(countries))]

# Group by 'BU/COE' and resample to monthly frequency, summing 'Total Incremental Revenue'
df_grouped = df_current_year.groupby('BU/COE')['Total Incremental Revenue'].resample('M').sum().reset_index()

# Split data into train and test sets
train_data, test_data = train_test_split(df_grouped, test_size=0.2, random_state=42)

# Initialize empty DataFrame for predictions
predictions_df = pd.DataFrame(columns=['Close Month', 'BU/COE', 'Revenue Prediction'])

# Loop through each BU/COE in the training set
for group, df_group in train_data.groupby('BU/COE'):
    try:
        # Fit ARIMA model
        model = ARIMA(df_group['Total Incremental Revenue'], order=(1, 1, 1), seasonal_order=(0, 0, 0, 12))
        fitted_model = model.fit()
        
        # Forecast remaining months of the current year
        forecast_steps = 12 - current_month + 1
        forecast = fitted_model.forecast(steps=forecast_steps)
        
        # Append predictions with BU/COE and forecast
        for i, pred in enumerate(forecast):
            month = current_month + i
            predictions_df = predictions_df.append({'Close Month': pd.to_datetime(f"{current_year}-{month}-01", format='%Y-%m-%d'), 'BU/COE': group, 'Revenue Prediction': pred}, ignore_index=True)
    except:
        print(f"Unable to fit ARIMA model for {group}")

# Merge actual and predicted values on 'Close Month' and 'BU/COE'
merged_df = pd.merge(test_data, predictions_df, on=['Close Month', 'BU/COE'], how='left')

# Calculate actual values for comparison
actual_values = merged_df.pivot(index='Close Month', columns='BU/COE', values='Total Incremental Revenue').sum(axis=1)

# Calculate predicted values
predicted_values = merged_df.pivot(index='Close Month', columns='BU/COE', values='Revenue Prediction').sum(axis=1)

# Drop rows with missing values
actual_values.dropna(inplace=True)
predicted_values.dropna(inplace=True)

# Calculate metrics
mae = mean_absolute_error(actual_values, predicted_values)
mse = mean_squared_error(actual_values, predicted_values)
rmse = np.sqrt(mse)
mape = np.mean(np.abs((actual_values - predicted_values) / actual_values)) * 100

# Print metrics
print(f"Mean Absolute Error (MAE): {mae}")
print(f"Mean Squared Error (MSE): {mse}")
print(f"Root Mean Squared Error (RMSE): {rmse}")
print(f"Mean Absolute Percentage Error (MAPE): {mape}")

# Visualize actual vs predicted values
plt.figure(figsize=(10, 6))
plt.plot(actual_values.index, actual_values, label='Actual')
plt.plot(predicted_values.index, predicted_values, label='Predicted')
plt.xlabel('Date')
plt.ylabel('Total Incremental Revenue')
plt.title('Actual vs Predicted Total Incremental Revenue')
plt.legend()
plt.grid(True)
plt.show()
